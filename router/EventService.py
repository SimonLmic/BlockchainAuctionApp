import requests
import os, sys, csv, gzip, json

# external libs Server Sanic
from sanic import Sanic
from sanic import response
from sanic.response import json
from sanic.exceptions import NotFound

import ujson

# packages
sys.path.append('.')
from auction import blockchainWrapper, auctionEngine, adBank
from router import Router, Event
import store.Inventory as si

class EventService():
   '''
      The Event Service mediate events between E-commerce code XR Experience and the Blockchain Auction App.

         inbound: the Blockchain Auction App consume events generated by consumers on the XR Experience through Halogem middleware nodeJS server.

         outbound: the Blockchain Auction App publish events for users through our middleware nodeJS server.
   '''
   def __init__(self):
      self.app = Sanic()

   # encode an event
   def encode(self,eventJson):
      # compress, minify ultrajson
      eventJson = ujson.dumps(eventJson)
      minJson = eventJson.encode(encoding='utf-8',errors='strict')
      zipmin_Json = gzip.compress(minJson)
      sEvent = zipmin_Json
      print('zip length : {}'.format(len(zipmin_Json)))
      print('zip raw : {}'.format(sEvent))
      return sEvent

   # decode an event
   def decode(self,sEvent):
      # uncompress, minify
      import gzip
      eventJson = gzip.decompress(sEvent).decode(encoding='utf-8',errors='strict')
      print('Event decode : {}'.format(eventJson))
      return eventJson

   def start(self):

      @self.app.route('/event')
      async def test(request):
         self.generateEvent(self)
         resp = make_response(json({'event':'received'}), 200)
         resp.set_cookie('simon','cookie')
         # http://flask.pocoo.org/docs/1.0/api/#incoming-request-data
         # response.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)Â¶
         return resp

      @self.app.exception(NotFound)
      def not_found(request, exception):
         return response.json(
            {'message': 'Hello world!'},
            headers={'X-Served-By': 'Simon'},
            status=404,
         )

      @self.app.route('/cookie/')
      def get_cookie():
         #request.query_string # read query string
         cookie = request.cookies.get('name')
         return cookie

      @self.app.route('/display/', methods=['POST'])
      async def display(request):
         values = request.json
         '''
         Serve a 3D/XR content URL to middleware server
         then middleware server send it thru socket.io to user connected on my website
         '''
         bid_event = {'creative_url':values['creativeURL']}
         bid_event = values
         print("bid event data ".format(bid_event))

         r = requests.post('https://Simon-Laptop.local:443/display', json=bid_event,  verify=False)
         print(r)

         # serve creative
         return response.json(
            {'message': bid_event},
            headers={'X-Served-By': 'BlockchainAppAuction'},
            status=200,
         )

      self.app.run(host='0.0.0.0', port=8777)
      return

   def keep(self, event):
      eventJson = self.readEvent(event)
      publisher_type = eventJson['publisher']
      if publisher_type == 'media':
         print('publisher type : {}'.format(publisher_type))
      else :
         eventJson = {}
      return eventJson

   def log(self, event):
      currentPath = os.getcwd()
      outFile = currentPath+'/logTraffic.json'
      f =  open(outFile,'w')
      ujson.dump(event, f)
      # pickle python module for serialization
      print("log Event File : ", event)
      return

   def readEvent(self,event):
      eventJson = {'publisher':'media'}
      return eventJson

   # generate a user connected on my website event
   def generateEvent(self):
      '''
       request to website
       response is a server-to-server request
       translate the response into an Event
      '''
      server = 'http://127.0.0.1'
      service = 'event'
      user = 'user'
      pwd = 'pass'
      r = requests.get(server, auth=(user,pwd)) # url
      response = r.text # .json() server to server

      # generate ad network event
      event = response + " bla bla bla "
      event = self.keep(event)
      zipEvent =  self.encode(event)
      unzipEvent = self.decode(zipEvent)
      self.log(unzipEvent)
      return

if __name__ == "__main__":
   service = EventService()
   service.generateEvent()
   service.start()
